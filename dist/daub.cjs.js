"use strict";function _defineProperty(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function ownKeys(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),a.push.apply(a,n)}return a}function _objectSpread2(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?ownKeys(a,!0).forEach(function(t){_defineProperty(e,t,a[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):ownKeys(a).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))})}return e}function _interpretString(e){return null==e?"":String(e)}function _regexpWithoutGlobalFlag(e){let t=e.flags.replace("g","");return new RegExp(regExpToString(e),t)}function regExpToString(e){let t=e.toString();return t=(t=t.replace(/^\//,"")).replace(/\/[mgiy]*$/,"")}function escapeRegExp(e){return String(e).replace(/([.*+?^=!:${}()|[\]\/\\])/g,"\\$1")}function gsub(e,t,a){let n="";if("function"!=typeof a){let e=new Template(a);a=t=>e.evaluate(t)}if(t.flags&&t.flags.indexOf("g")>-1?t=_regexpWithoutGlobalFlag(t):"string"==typeof t&&(t=escapeRegExp(t)),!t)return(a=a(""))+e.split("").join(a)+a;for(;e.length>0;){let r=e.length,s=e.match(t);if(s){let t,p=a(s,e);if(Array.isArray(p)&&([p,t]=p),n+=e.slice(0,s.index),n+=_interpretString(p),(e=void 0!==t?e.slice(s.index+t):e.slice(s.index+s[0].length)).length===r)throw new Error("Infinite loop detected; none of the string was consumed.")}else n+=e,e=""}return n}Object.defineProperty(exports,"__esModule",{value:!0});class Template{constructor(e,t){this.template=String(e),this.pattern=t||Template.DEFAULT_PATTERN}evaluate(e){return gsub(this.template,this.pattern,t=>{if(null==e)return"";let a=t[1]||"";if("\\"==a)return t[2];let n=e,r=t[3],s=/^([^.[]+|\[((?:.*?[^\\])?)\])(\.|\[|$)/;if(null==(t=s.exec(r)))return a;for(;null!=t;){if(null==(n=n["["===t[1].charAt(0)?t[2].replace(/\\]/,"]"):t[1]])||""===t[3])break;r=r.substring("["===t[3]?t[1].length:t[0].length),t=s.exec(r)}return a+_interpretString(n)})}}function _isEscapedHash(e,t){return 0!==t&&"\\"===e.charAt(t-1)}function _trimCommentsFromLine(e){let t=-1;do{t=e.indexOf("#",t+1)}while(t>-1&&_isEscapedHash(e,t));return t>-1&&(e=e.substring(0,t)),e=e.trim()}function VerboseRegExp(e){let t=e.raw[0].split(/\n/).map(_trimCommentsFromLine).join("").replace(/\s/g,"");return t=t.replace(/(\\)(\\)(\d+)/g,(e,t,a,n)=>"".concat(a).concat(n)),new RegExp(t)}Template.DEFAULT_PATTERN=/(^|.|\r|\n)(#\{(.*?)\})/,Template.interpolate=function(e,t){return new Template(e).evaluate(t)};var verboseRegexp={VerboseRegExp:VerboseRegExp},verboseRegexp_1=verboseRegexp.VerboseRegExp;function balance(e,t,a){let n,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};r=Object.assign({startIndex:0,stackDepth:0,considerEscapes:!0},r);let{startIndex:s,stackDepth:p,considerEscapes:i}=r,o=t.length,l=a.length,c=e.length;for(let r=s;r<c;r++){r>0&&(n=e.slice(r-1,r));let s=!!i&&"\\"===n,c=e.slice(r,r+o);if(e.slice(r,r+l)!==a||s||p++,c===t&&!s&&0===--p)return r}return-1}function compact(e){return e=(e=e.replace(/^[\s\t]*/gm,"")).replace(/\n/g,"")}function wrap(e,t){return e?'<span class="'.concat(t,'">').concat(e,"</span>"):""}function _getLastToken(e){for(let t=e.length-1;t>=0;t--){let a=e[t];if("string"!=typeof a)return Array.isArray(a.content)?_getLastToken(a.content):a}return null}function balanceByLexer(e,t){let a=_getLastToken(t.run(e).tokens);return a.index+a.content.length-1}function flattenTokens(e){let t=[];return function e(a){a.forEach(a=>{t.push(a),Array.isArray(a.content)&&e(a.content)})}(e),t}var Utils=Object.freeze({balance:balance,balanceByLexer:balanceByLexer,compact:compact,escapeRegExp:escapeRegExp,flattenTokens:flattenTokens,gsub:gsub,regExpToString:regExpToString,wrap:wrap,VerboseRegExp:verboseRegexp_1});class Context{constructor(e){e.highlighter&&(this.highlighter=e.highlighter),this.storage=new Map}set(e,t){this.storage.set(e,t)}get(e,t){return this.storage.has(e)?this.storage.get(e):(this.storage.set(e,t),t)}}class ParseError extends Error{constructor(e){super(e),this.name="ParseError"}}class Grammar{constructor(e,t){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};"object"!=typeof e||t?(this.name=e,this.names=[e,...a.alias||[]],this._classNamePattern=new RegExp("\\b(?:"+this.names.join("|")+")\\b")):(this.name=null,a=t||a,t=e),this.options=a,this.rules=[],this._originalRules=t,this.extend(t),this.name&&this.names.forEach(e=>{console.log("REGISTERING:",e,this),Grammar.register(e,this)})}_toObject(){return _objectSpread2({},this._originalRules)}parse(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,a=this.pattern;return a.lastIndex=0,a.test(e)?gsub(e,a,(e,n)=>{let r,s,p,i=0,o=1;for(;r=this.rules[i++];){if(!e[o]){o+=r.length;continue}if(r.index&&((p=r.index(e[0],t))<=0&&(p=void 0),void 0!==p&&(s=p+1,n=n.slice(0,e.index+s),!(e=a.exec(n))||!e[o]))){let t=new ParseError('Bad "index" callback; requested substring did not match original rule.');throw Object.assign(t,{rule:r,source:n,match:e,index:p}),t}let i=[];for(let t=0;t<=r.length;t++)i.push(e[o+t]);if(i.name=r.name,r.captures)for(let e=0;e<i.length;e++){if(!(e in r.captures))continue;let a=r.captures[e];"function"==typeof a&&(a=a()),"string"==typeof a?i[e]=wrap(i[e],a):a instanceof Grammar&&i[e]&&(i[e]=a.parse(i[e],t))}if(r.before){let e=r.before(i,t);void 0!==e&&(i=e)}let l=r.replacement;i.name||(i.name=r.name),i.index=e.index;let c=l.evaluate(i);if(r.after){let e=r.after(c,t);void 0!==e&&(c=e)}return void 0!==p?[c,s]:c}return""}):e}_makeRules(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,a=[];for(let n in e){let r=new Rule(n,e[n],t);a.push(r),t+=r.length}return a}match(e){return this._classNamePattern.test(e)}extend(){let e;for(var t=arguments.length,a=new Array(t),n=0;n<t;n++)a[n]=arguments[n];if(1!==a.length)return a.forEach(e=>this.extend(e)),this;if((e=a[0])instanceof Grammar&&(e=e.toObject()),!e)throw new Error("Nonexistent grammar!");let r=0;this.rules.length&&(r=this.rules.map(e=>e.length).reduce((e,t)=>e+t));let s=e,p=this._makeRules(s,r);return this.rules.push(...p),this.pattern=new RegExp(this.rules.map(e=>e.pattern).join("|"),this.options.ignoreCase?"mi":"m"),this}toObject(){let e={};return this.rules.forEach(t=>{e[t.name]=t.toObject()}),e}}const MAP={};Grammar.register=(e,t)=>{MAP[e]=t},Grammar.find=e=>(console.log("looking up:",e,MAP),MAP[e]||null),Grammar.debug=()=>MAP;class Rule{constructor(e,t,a){this.name=e;let n=t.replacement;n?this.replacement=n instanceof Template?n:new Template(n):t.captures?this.replacement=null:this.replacement=Rule.DEFAULT_TEMPLATE,this.debug=t.debug,this.before=t.before,this.after=t.after,this.index=t.index,this.captures=t.captures;let r=t.pattern,s=t.pattern;"string"!=typeof s&&(s=regExpToString(s));let p=((s=s.replace(/\\(\d+)/g,(e,t)=>{let n=Number(t);return"\\".concat(a+n+1)})).match(/\(/g)||"").length,i=(s.match(/\(\?[:!=]/g)||"").length+(s.match(/\\\(/g)||"").length-(s.match(/\\\(\?[:!=]/g)||"").length;this.length=p+1-i,this.pattern="(".concat(s,")"),this.originalPattern=r,this.replacement||(this.replacement=Rule.makeReplacement(this.length,t.wrapReplacement))}toObject(){return{pattern:this.originalPattern,replacement:this.replacement,before:this.before,after:this.after,index:this.index,captures:this.captures}}}Rule.DEFAULT_TEMPLATE=new Template('<span class="#{name}">#{0}</span>'),Rule.makeReplacement=(e,t)=>{let a=[];for(let t=1;t<e;t++)a.push(t);let n=a.join("}#{");n="#{".concat(n,"}");let r=t?'<span class="#{name}">'.concat(n,"</span>"):n;return new Template(r)};class AsyncHighlighter{constructor(){let{worker:e,node:t}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(this.worker=e,this.node=t||document.body,!(this.worker instanceof Worker))throw new TypeError('Invalid "worker" option.');if(!("nodeType"in this.node))throw new TypeError('Invalid "node" option.');this._setupWorker(),this.uid=0}addElement(e){this.elements.indexOf(e)>-1||this.elements.push(e)}_getLanguage(e){let t=e.getAttribute("data-language");return t||(t=e.className),t}scan(){console.log("AsyncHighlighter#scan");let e=Array.from(this.node.querySelectorAll("code:not([data-daub-highlighted])"));e&&e.length&&e.forEach(e=>{console.log("AsyncHighlighter Handling node:",e);let t=this.uid;e.setAttribute("data-daub-uid",this.uid++);let a=e.innerHTML,n=this._getLanguage(e);this.parse(a,n,t,t=>{console.log("[AsyncHighlighter] Got source back:",a),this._updateElement(e,t,n),e.setAttribute("data-daub-highlighted","true");let r={element:e,language:n};this._fire("highlighted",e,r,{cancelable:!1})})})}_handleMessage(e){console.log("AsyncHighlighter handling message:",e);let{id:t,language:a,source:n}=e.data,r=this.node.querySelector('[data-daub-uid="'.concat(t,'"]'));console.log(" does the element exist?",t,r),r&&this._updateElement(r,n,a)}_setupWorker(){console.log("setting up worker:",this.worker),this.worker.onmessage=e=>this._handleMessage(e)}_updateElement(e,t,a){e.ownerDocument;let n=document.createRange().createContextualFragment(t),r={element:e,language:a,fragment:n},s=this._fire("will-highlight",e,r);s.defaultPrevented||s.detail.fragment&&(n=s.detail.fragment,e.innerHTML="",e.appendChild(n))}_fire(e,t,a){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};a=_objectSpread2({highlighter:this},a);let r=_objectSpread2({bubbles:!0,cancelable:!0},n,{detail:a}),s=new CustomEvent("daub-".concat(e),r);return t.dispatchEvent(s),s}parse(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,a=arguments.length>2?arguments[2]:void 0;if(!t)throw new Error("Must specify a language!");this.worker.postMessage({type:"parse",text:e,id:a,language:t})}}class Highlighter{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.grammars=[],this._grammarTable={},this.elements=[],this.options=Object.assign({},Highlighter.DEFAULT_OPTIONS,e)}addElement(e){this.elements.indexOf(e)>-1||this.elements.push(e)}addGrammar(e){if(!e.name)throw new Error("Can't register a grammar without a name.'");this.grammars.indexOf(e)>-1||(this.grammars.push(e),e.name&&(this._grammarTable[e.name]=e))}scan(e){this.grammars.forEach(t=>{let a=t.names.map(e=>{let t=this.options.classPrefix+e;return"code.".concat(t,":not([data-highlighted])")}).join(", "),n=e.querySelectorAll(a);(n=Array.from(n))&&n.length&&n.forEach(e=>{if(e.hasAttribute("data-daub-highlighted"))return;let a=new Context({highlighter:this}),n=e.innerHTML;t.options.encode&&(n=n.replace(/</g,"&lt;"));let r=this.parse(n,t,a);this._updateElement(e,r,t),e.setAttribute("data-daub-highlighted","true");let s={element:e,grammar:t};this._fire("highlighted",e,s,{cancelable:!1})})})}highlight(){this.elements.forEach(e=>this.scan(e))}_updateElement(e,t,a){let n=e.ownerDocument.createRange().createContextualFragment(t),r={element:e,grammar:a,fragment:n},s=this._fire("will-highlight",e,r);s.defaultPrevented||(s.detail.fragment&&(n=s.detail.fragment),e.innerHTML="",e.appendChild(n))}_fire(e,t,a){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};Object.assign(a,{highlighter:this});let r=Object.assign({bubbles:!0,cancelable:!0},n,{detail:a}),s=new CustomEvent("daub-".concat(e),r);return t.dispatchEvent(s),s}parse(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if("string"==typeof t){if(!(t=this._grammarTable[t]))return e}else if(!t)throw new Error("Must specify a grammar!");return a||(a=new Context({highlighter:this})),t.parse(e,a)}}function resolve(e){return"function"==typeof e?e():e}function determineIfFinal(e,t){let a=e.final;if("boolean"==typeof a)return a;if("function"==typeof a)return a(t);if(a)throw new TypeError("Invalid value for rule.final!");return!1}Highlighter.DEFAULT_OPTIONS={classPrefix:""};class LexerError extends Error{constructor(e){super(e),this.name="LexerError"}}class Token{constructor(e,t,a,n){this.name=e,this.content=t,this.index=n+a}}class Lexer{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"";this.rules=e,this.name=t}addRules(e){this.rules.push(...e)}[Symbol.iterator](){let e=[];for(let t of this.rules)if(t.include){let a=resolve(t.include);e.push([...a])}else e.push(t);return e.values()}run(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,{startIndex:a=0}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},n=[];t||(t=new Map);let r=null,s=a;for(;e;){let a,p,i;for(let n of this){if((i=n.pattern.exec(e))&&n.test){n.test(i,e,t,n.pattern)||(i=null)}if(i){if(0===i.index){p=i,a=n;break}(!p||i.index<p.index)&&(p=i,a=n)}}if(!p)break;let o=p.index,l=p.index+p[0].length;if(p.index>0){let t=e.slice(0,p.index);n.push(t),s+=t.length,o=0}e=e.slice(l);let c=determineIfFinal(a,t),u=c&&a.skipSubRulesIfFinal;if(a.raw)n.push(p[0]),s+=p[0].length;else if(!a.inside&&!a.after||u){let e=new Token(a.name,p[0],o,s);n.push(e),s+=p[0].length}else{let r,i,l;if(a.inside?(l="inside",r=a.inside.name,i=resolve(a.inside.lexer)):(l="after",r=a.after.name,i=resolve(a.after.lexer)),!(i&&i instanceof Lexer))throw new LexerError("Invalid lexer!");let c=new Token(a.name,p[0],o,s),u=s+p[0].length-o,m=[];"inside"===l?m.push(c):n.push(c);let d=i.run(e,t,{startIndex:u});m.push(...d.tokens);let g=new Token(r,m,o,s);n.push(g),s=d.lengthConsumed,e=d.text}if(c)break;if(e===r)break;r=e}return{tokens:n,text:e,lengthConsumed:s}}}const{balance:balance$1,compact:compact$1,VerboseRegExp:VerboseRegExp$1}=Utils;let PARAMETERS=new Grammar({parameter:{pattern:/(?:\b|^)((?:(?:[A-Za-z_$][\w\d]*)\s)*)(\s*)([a-zA-Z_$:][\w\d]*)(?=,|$)/,replacement:compact$1('\n      <span class="parameter">\n        <span class="storage storage-type">#{1}</span>\n        #{2}\n        <span class="variable">#{3}</span>\n      </span>\n    '),captures:{1:()=>STORAGE}}}),ESCAPES=new Grammar({escape:{pattern:/\\./}});const DECLARATIONS=new Grammar({"meta: function":{pattern:/([A-Za-z_$]\w*)(\s+)([a-zA-Z_$:]\w*)(\s*)(\()(.*)(\))(\s*)(?={)/,index(e){let t=balance$1(e,")","(",{startIndex:e.indexOf("(")});return e.indexOf("{",t)-1},replacement:"<b><span class='storage storage-type storage-return-type'>#{1}</span>#{2}#{3}#{4}#{5}#{6}#{7}#{8}</b>",captures:{3:"entity",6:()=>PARAMETERS}},"meta: bare declaration":{pattern:/\b([A-Za-z_$][\w\d]*)(\s+)([A-Za-z_$][\w\d]*)(\s*)(?=;)/,captures:{1:"storage storage-type",3:"variable"}},"meta: declaration with assignment":{pattern:/\b([A-Za-z_$][\w\d]*)(\s+)([A-Za-z_$][\w\d]*)(\s*)(=)/,captures:{1:"storage storage-type",3:"variable",5:"operator"}},"meta: array declaration":{pattern:/\b([A-Za-z_$][\w\d]*)(\s+)([A-Za-z_$][\w\d]*)(\[)(\d+)(\])/,captures:{1:"storage storage-type",3:"variable",4:"punctuation",5:"number",6:"punctuation"}},"meta: declaration with parens":{pattern:/\b([A-Za-z_$][\w\d]*)(\s+)([A-Za-z_$][\w\d]*)(\s*)(\()([\s\S]*)(\))(;)/,index(e){let t=balance$1(e,")","(")+1;return e.indexOf(";",t)},captures:{1:"storage storage-type",3:"variable",5:"punctuation",6:()=>VALUES,7:"punctuation"}},"meta: class declaration":{pattern:/\b(class|enum)(\s+)([A-Za-z][A-Za-z0-9:_$]*)(\s*)({)/,captures:{1:"storage storage-type",3:"entity entity-class"}}}),VALUES=new Grammar({constant:{pattern:/\b[A-Z_]+\b/},lambda:{pattern:/(\[\])(\s*)(\()([\s\S]*)(\))(\s*)({)([\s\S]*)(})/,index:e=>balance$1(e,"}","{",{startIndex:e.indexOf("{")}),wrapReplacement:!0,captures:{1:"punctuation",3:"punctuation",4:()=>PARAMETERS,5:"punctuation",7:"punctuation",8:()=>MAIN,9:"punctuation"}},"constant constant-boolean":{pattern:/\b(?:true|false)\b/},"string string-single-quoted":{pattern:/(')((?:[^'\\]|\\\\|\\')*)(')/,wrapReplacement:!0,captures:{2:()=>ESCAPES}},"string string-double-quoted":{pattern:/(")((?:[^"\\]|\\\\|\\")*)(")/,wrapReplacement:!0,captures:{2:()=>ESCAPES}},number:{pattern:/\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i}}),COMMENTS=new Grammar({comment:{pattern:/(\/\/[^\n]*(?=\n|$))|(\/\*[^*]*\*+([^\/][^*]*\*+)*\/)/}}),STORAGE=new Grammar({"storage storage-type":{pattern:/\b(?:u?int(?:8|16|36|64)_t|int|long|float|double|char(?:16|32)_t|char|class|bool|wchar_t|volatile|virtual|extern|mutable|const|unsigned|signed|static|struct|template|private|protected|public|mutable|volatile|namespace|struct|void|short|enum)/}}),MACRO_VALUES=new Grammar({}).extend(COMMENTS,VALUES),MACROS=new Grammar({"macro macro-define":{pattern:/^(\#define)(\s+)(\w+)(.*?)$/,replacement:compact$1('\n      <span class="keyword keyword-macro">#{1}</span>#{2}\n      <span class="entity entity-macro">#{3}</span>\n      #{4}\n    '),captures:{1:"keyword keyword-macro",3:"entity entity-macro",4:()=>MACRO_VALUES}},"macro macro-include":{pattern:/^(\#include)(\s+)("|<|&lt;)(.*?)("|>|&gt;)(?=\n|$)/,replacement:compact$1('\n      <span class="keyword keyword-macro">#{1}</span>#{2}\n      <span class="string string-include">\n        <span class="punctuation">#{3}</span>\n        #{4}\n        <span class="punctuation">#{5}</span>\n      </span>\n    ')},"macro macro-with-one-argument":{pattern:/(\#(?:ifdef|ifndef|undef|if))(\s+)(\w+)/,captures:{1:"keyword keyword-macro",3:"entity entity-macro"}},"macro macro-error":{pattern:/(#error)(\s*)(")(.*)(")/,replacement:compact$1('\n      <span class="keyword keyword-macro">#{1}</span>\n      #{2}\n      <span class="string string-quoted">#{3}#{4}#{5}</span>\n    ')},"keyword keyword-macro":{pattern:/#(endif|else)/}}),MAIN=new Grammar("arduino",{"keyword keyword-control":{pattern:/\b(?:alignas|alignof|asm|auto|break|case|catch|compl|constexpr|const_cast|continue|decltype|default|delete|do|dynamic_cast|else|explicit|export|for|friend|goto|if|inline|new|noexcept|nullptr|operator|register|reinterpret_cast|return|sizeof|static_assert|static_cast|switch|template|this|thread_local|throw|try|typedef|typeid|typename|union|using|while)\b/}}).extend(COMMENTS,DECLARATIONS);MAIN.extend(MACROS,VALUES,STORAGE,{operator:{pattern:/--?|\+\+?|!=?|(?:<|&lt;){1,2}=?|(&gt;|>){1,2}=?|-(?:>|&gt;)|:{1,2}|={1,2}|\^|~|%|&{1,2}|\|\|?|\?|\*|\/|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/}});const{balanceByLexer:balanceByLexer$1,compact:compact$2,VerboseRegExp:VerboseRegExp$2}=Utils,LEXER_STRING=new Lexer([{name:"string-escape",pattern:/\\./},{name:"string-end",pattern:/('|")/,test:(e,t,a)=>{let n=a.get("string-begin"),r=e.exec(t);return!!r&&(r[1]===n&&(a.set("string-begin",null),r))},final:!0}]),LEXER_ATTRIBUTE_VALUE=new Lexer([{name:"string-begin",pattern:/^\s*('|")/,test:(e,t,a)=>{let n=e.exec(t);return!!n&&(a.set("string-begin",n[1]),n)},inside:{name:"string",lexer:LEXER_STRING}}]),LEXER_ATTRIBUTE_SEPARATOR=new Lexer([{name:"punctuation",pattern:/^=/,after:{name:"attribute-value",lexer:LEXER_ATTRIBUTE_VALUE}}]),LEXER_TAG=new Lexer([{name:"tag tag-html",pattern:/^[a-z]+(?=\s)/},{name:"attribute-name",pattern:/^\s*(?:\/)?[a-z]+(?=\=)/,after:{name:"attribute-separator",lexer:LEXER_ATTRIBUTE_SEPARATOR}},{name:"punctuation",pattern:/\/(?:>|&gt;)/,final:!0},{name:"punctuation",pattern:/(>|&gt;)/,final:!0}]),LEXER_TAG_START=new Lexer([{name:"punctuation",pattern:/^(?:<|&lt;)/,after:{name:"tag",lexer:LEXER_TAG}}]),ATTRIBUTES=new Grammar({string:{pattern:/('[^']*[^\\]'|"[^"]*[^\\]")/},attribute:{pattern:/\b([a-zA-Z-:]+)(=)/,replacement:compact$2("\n      <span class='attribute'>\n        <span class='#{name}'>#{1}</span>\n        <span class='punctuation'>#{2}</span>\n      </span>\n    ")}}),MAIN$1=new Grammar("html",{doctype:{pattern:/&lt;!DOCTYPE([^&]|&[^g]|&g[^t])*&gt;/},"embedded embedded-javascript":{pattern:/(&lt;|<)(script|SCRIPT)(\s+.*?)?(&gt;|>)([\s\S]*?)((?:&lt;|<)\/)(script|SCRIPT)(&gt;|>)/,replacement:compact$2("\n      <span class='element element-opening'>\n        <span class='punctuation'>#{1}</span>\n        <span class='tag'>#{2}</span>#{3}\n        <span class='punctuation'>#{4}</span>\n      </span>\n        #{5}\n      <span class='element element-closing'>\n        <span class='punctuation'>#{6}</span>\n        <span class='tag'>#{7}</span>\n        <span class='punctuation'>#{8}</span>\n      </span>\n    "),before:(e,t)=>{e[3]&&(e[3]=ATTRIBUTES.parse(e[3],t)),e[5]=t.highlighter.parse(e[5],"javascript",t)}},"tag tag-open":{pattern:/((?:<|&lt;))([a-zA-Z0-9:]+\s*)([\s\S]*)(\/)?(&gt;|>)/,index:function(e){return balanceByLexer$1(e,LEXER_TAG_START)},replacement:compact$2("\n      <span class='element element-opening'>\n        <span class='punctuation'>#{1}</span>\n        <span class='tag'>#{2}</span>#{3}\n        <span class='punctuation'>#{4}#{5}</span>\n      </span>#{6}\n    "),before:(e,t)=>{e[3]=ATTRIBUTES.parse(e[3],t)}},"tag tag-close":{pattern:/(&lt;\/)([a-zA-Z0-9:]+)(&gt;)/,replacement:compact$2("\n      <span class='element element-closing'>\n        <span class='punctuation'>#{1}</span>\n        <span class='tag'>#{2}</span>\n        <span class='punctuation'>#{3}</span>\n      </span>\n    ")},comment:{pattern:/&lt;!\s*(--([^-]|[\r\n]|-[^-])*--\s*)&gt;/}},{encode:!0}),{balance:balance$2,compact:compact$3,wrap:wrap$1,VerboseRegExp:VerboseRegExp$3}=Utils;let ESCAPES$1=new Grammar({escape:{pattern:/\\./}}),REGEX_INTERNALS=new Grammar({escape:{pattern:/\\./},"exclude from group begin":{pattern:/(\\\()/,replacement:"#{1}"},"group-begin":{pattern:/(\()/,replacement:'<b class="group">#{1}'},"group-end":{pattern:/(\))/,replacement:"#{1}</b>"}});function handleParams(e,t){return PARAMETERS$1.parse(e,t)}let INSIDE_TEMPLATE_STRINGS=new Grammar({interpolation:{pattern:/(\$\{)(.*?)(\})/,replacement:"<span class='#{name}'><span class='punctuation'>#{1}</span><span class='interpolation-contents'>#{2}</span><span class='punctuation'>#{3}</span></span>",before:(e,t)=>{e[2]=MAIN$2.parse(e[2],t)}}}).extend(ESCAPES$1);const PARAMETERS$1=new Grammar({"parameter parameter-with-default":{pattern:/([A-Za-z$_][$_A-Za-z0-9_]*)(\s*=\s*)(.*?)(?=,|\)|\n|$)/,replacement:compact$3('\n      <span class="parameter">\n        <span class="variable">#{1}</span>\n        <span class="operator">#{2}</span>\n      #{3}\n      </span>\n    '),before:(e,t)=>{e[3]=VALUES$1.parse(e[3],t)}},"keyword operator":{pattern:/\.{3}/},"variable parameter":{pattern:/[A-Za-z$_][$_A-Za-z0-9_]*/}});let STRINGS=new Grammar({"string string-template embedded":{pattern:/(`)([^`]*)(`)/,replacement:"<span class='#{name}'>#{1}#{2}#{3}</span>",before:(e,t)=>{e[2]=INSIDE_TEMPLATE_STRINGS.parse(e[2],t)}},"string string-single-quoted":{pattern:/(')((?:[^'\\]|\\\\|\\[^'])*)(')/,replacement:"<span class='#{name}'>#{1}#{2}#{3}</span>",before:(e,t)=>{e[2]=ESCAPES$1.parse(e[2],t)}},"string string-double-quoted":{pattern:/(")((?:[^"\\]|\\\\|\\[^"])*)(")/,replacement:"<span class='#{name}'>#{1}#{2}#{3}</span>",before:(e,t)=>{e[2]=ESCAPES$1.parse(e[2],t)}}}),VALUES$1=new Grammar(_objectSpread2({constant:{pattern:/\b(?:arguments|this|false|true|super|null|undefined)\b/},"number number-binary-or-octal":{pattern:/0[bo]\d+/},number:{pattern:/(?:\d*\.?\d+)/}},STRINGS.toObject(),{comment:{pattern:/(\/\/[^\n]*\n)|(\/\*[^*]*\*+([^\/][^*]*\*+)*\/)/},regexp:{pattern:/(\/)(.*?[^\\])(\/)([mgiy]*)/,replacement:"<span class='regexp'>#{1}#{2}#{3}#{4}</span>",before:(e,t)=>{e[2]=REGEX_INTERNALS.parse(e[2],t),e[4]&&(e[4]=wrap$1(e[4],"keyword regexp-flags"))}}})),DESTRUCTURING=new Grammar({alias:{pattern:/([A-Za-z$_][$_A-Za-z0-9_]*)(\s*)(:)(\s*)(?=\w|\{|\[)/,replacement:"<span class='entity'>#{1}</span>#{2}#{3}#{4}"},variable:{pattern:/[A-Za-z$_][$_A-Za-z0-9_]*/}}),MAIN$2=new Grammar("javascript",{},{alias:["js"]});MAIN$2.extend(VALUES$1),MAIN$2.extend({"meta: digits in the middle of identifiers":{pattern:/\$\d/,replacement:"#{0}"},"meta: properties with keyword names":{pattern:/(\.)(for|if|while|switch|catch|return)\b/,replacement:"#{0}"},"meta: functions with keyword names":{pattern:/(\s*)\b(for|if|while|switch|catch)\b/,replacement:"#{1}<span class='keyword'>#{2}</span>"},"meta: fat arrow function, one arg, no parens":{pattern:/([a-zA-Z_$][a-zA-Z0-9_$]*)(\s*)(=(?:&gt;|>))/,replacement:"#{1}#{2}#{3}",before:(e,t)=>{e[1]=handleParams(e[1],t)}},"meta: fat arrow function, args in parens":{pattern:/(\()([^\)]*?)(\))(\s*)(=(?:&gt;|>))/,replacement:"#{1}#{2}#{3}#{4}#{5}",before:(e,t)=>{e[2]=handleParams(e[2],t)}},"keyword keyword-new":{pattern:/new(?=\s[A-Za-z_$])/},"variable variable-declaration":{pattern:/\b(var|let|const)(\s+)([A-Za-z_$][_$A-Z0-9a-z]*?)(?=\s|=|;|,)/,replacement:"<span class='storage'>#{1}</span>#{2}<span class='#{name}'>#{3}</span>"},"variable variable-assignment":{pattern:/(\s+|,)([A-Za-z_$][\w\d$]*?)(\s*)(?==)/,replacement:"#{1}<span class='#{name}'>#{2}</span>#{3}"},"meta: destructuring assignment":{pattern:/(let|var|const)(\s+)(\{|\[)([\s\S]*)(\}|\])(\s*)(?==)/,index:e=>{let t=/(let|var|const|)(\s+)(\{|\[)/.exec(e)[3];return balance$2(e,t,{"{":"}","[":"]"}[t],{startIndex:e.indexOf(t)+1})},replacement:"<span class='storage'>#{1}</span>#{2}#{3}#{4}#{5}#{6}#{7}",before:(e,t)=>{e[4]=DESTRUCTURING.parse(e[4],t)}},"function function-expression":{pattern:/\b(function)(\s*)([a-zA-Z_$]\w*)?(\s*)(\()(.*?)(\))/,replacement:"<span class='keyword keyword-function'>#{1}</span>#{2}#{3}#{4}#{5}#{6}#{7}",before:function(e,t){return e[3]&&(e[3]="<span class='entity'>".concat(e[3],"</span>")),e[6]=handleParams(e[6],t),e}},"function function-literal-shorthand-style":{pattern:/(^\s*)(get|set|static)?(\s*)([a-zA-Z_$][a-zA-Z0-9$_]*)(\s*)(\()(.*?)(\))(\s*)(\{)/,replacement:"#{1}#{2}#{3}<span class='entity'>#{4}</span>#{5}#{6}#{7}#{8}#{9}#{10}",before:(e,t)=>{e[2]&&(e[2]="<span class='storage'>".concat(e[1],"</span>")),e[7]=handleParams(e[7],t)}},"function function-assigned-to-variable":{pattern:/\b([a-zA-Z_?\.$]+\w*)(\s*)(=)(\s*)(function)(\s*)(\()(.*?)(\))/,replacement:"<span class='variable'>#{1}</span>#{2}#{3}#{4} <span class='keyword'>#{5}</span>#{6}#{7}#{8}#{9}",before:(e,t)=>{e[8]=handleParams(e[8],t)}},"meta: property then function":{pattern:/([A-Za-z_$][A-Za-z0-9_$]*)(:)(\s*)(?=function)/,replacement:"<span class='entity'>#{1}</span>#{2}#{3}"},entity:{pattern:/([A-Za-z_$][A-Za-z0-9_$]*)(?=:)/},"meta: class definition":{pattern:/(class)(?:(\s+)([A-Z][A-Za-z0-9_]*))?(?:(\s+)(extends)(\s+)([A-Z][A-Za-z0-9_$\.]*))?(\s*)({)/,index:e=>balance$2(e,"}","{",{startIndex:e.indexOf("{")+1}),replacement:compact$3('\n      <span class="storage">#{1}</span>\n      #{2}#{3}\n      #{4}#{5}#{6}#{7}\n      #{8}#{9}\n    '),before:e=>{e[3]&&(e[3]=wrap$1(e[3],"entity entity-class")),e[5]&&(e[5]=wrap$1(e[5],"storage")),e[7]&&(e[7]=wrap$1(e[7],"entity entity-class entity-superclass"))}},storage:{pattern:/\b(?:var|let|const|class|extends|async)\b/},keyword:{pattern:/\b(?:try|catch|finally|if|else|do|while|for|break|continue|case|switch|default|return|yield|throw|await)\b/},"keyword operator":{pattern:/!==?|={1,3}|>=?|<=?|\+\+|\+|--|-|\*|[\*\+-\/]=|\?|\.{3}|\b(?:instanceof|in|of)\b/}});const{balance:balance$3,balanceByLexer:balanceByLexer$2,compact:compact$4,wrap:wrap$2,VerboseRegExp:VerboseRegExp$4}=Utils,LEXER_STRING$1=new Lexer([{name:"string-escape",pattern:/\\./},{name:"string-end",pattern:/('|")/,test:(e,t,a)=>{let n=a.get("string-begin");return e[1]===n&&(a.set("string-begin",null),e)},final:!0}],"string"),LEXER_BALANCE_BRACES=new Lexer([{name:"punctuation",pattern:/\{/,inside:{lexer:()=>LEXER_BALANCE_BRACES}},{name:"punctuation",pattern:/\}/,final:!0}],"balance-braces"),LEXER_TEMPLATE_STRING_INTERPOLATION=new Lexer([{name:"exclude escaped closing brace",pattern:/\\\}/,raw:!0},{name:"interpolation-end",pattern:/\}/,final:!0}],"template-string-interpolation"),LEXER_TEMPLATE_STRING=new Lexer([{name:"interpolation-start",pattern:/(\$\{)/,inside:{name:"interpolation",lexer:LEXER_TEMPLATE_STRING_INTERPOLATION}},{name:"exclude escaped backtick",pattern:/\\\x60/,raw:!0},{name:"string-end",pattern:/\x60/,final:!0}],"template-string"),LEXER_JSX_INTERPOLATION=new Lexer([{name:"punctuation",pattern:/\{/,inside:{lexer:LEXER_BALANCE_BRACES}},{name:"exclude escaped closing brace",pattern:/\\\}/,raw:!0},{name:"string-begin",pattern:/^\s*('|")/,test:(e,t,a)=>(a.set("string-begin",e[1]),e),inside:{name:"string",lexer:LEXER_STRING$1}},{name:"template-string-begin",pattern:/\x60/,inside:{name:"template-string",lexer:LEXER_TEMPLATE_STRING}},{name:"interpolation-end",pattern:/\}/,final:!0}],"jsx-interpolation"),LEXER_BEFORE_JSX_INTERPOLATION=new Lexer([{name:"interpolation-begin",pattern:/^\{/,inside:{name:"interpolation",lexer:LEXER_JSX_INTERPOLATION}}],"before-jsx-interpolation"),LEXER_ATTRIBUTE_VALUE$1=new Lexer([{name:"interpolation-begin",pattern:/^\{/,inside:{name:"interpolation",lexer:LEXER_JSX_INTERPOLATION},final:!0},{name:"string-begin",pattern:/^\s*('|")/,test:(e,t,a)=>(a.set("string-begin",e[1]),e),inside:{name:"string",lexer:LEXER_STRING$1}}],"attribute-value"),LEXER_ATTRIBUTE_SEPARATOR$1=new Lexer([{name:"punctuation",pattern:/^=/,after:{name:"attribute-value",lexer:LEXER_ATTRIBUTE_VALUE$1}}],"attribute-separator"),LEXER_JSX_CLOSING_TAG=new Lexer([{name:"tag tag-html",pattern:/^[a-z]+(?=&gt;|>)/},{name:"tag tag-jsx",pattern:/^[A-Z][A-Za-z0-9_$\.]*(?=&gt;|>)/},{name:"punctuation",pattern:/^\s*(?:>|&gt;)/,test:(e,t,a)=>{let n=a.get("jsx-tag-depth");if(n<1)throw new Error("Depth error!");return n--,a.set("jsx-tag-depth",n),e},final:!0}],"jsx-closing-tag"),LEXER_INSIDE_TAG=new Lexer([{name:"punctuation",pattern:/^\s*\{/,inside:{name:"interpolation",lexer:LEXER_JSX_INTERPOLATION}},{name:"attribute-name",pattern:/^\s*[a-zA-Z][a-zA-Z0-9_$]+(?=\=)/,after:{name:"attribute-separator",lexer:LEXER_ATTRIBUTE_SEPARATOR$1}},{name:"punctuation",pattern:/^\s*\/(?:>|&gt;)/,test:(e,t,a)=>(a.set("is-opening-tag",null),e),final:e=>e.get("is-root")},{name:"punctuation",pattern:/^\s*(>|&gt;)/,test:(e,t,a)=>{let n=a.get("is-opening-tag"),r=a.get("jsx-tag-depth");return 0!==(r+=n?1:-1)&&(a.set("jsx-tag-depth",r),a.set("is-opening-tag",null),e)},final:e=>{let t=e.get("jsx-tag-depth");return e.get("only-opening-tag")||0===t},skipSubRulesIfFinal:!0,after:{name:"jsx-contents",lexer:()=>LEXER_WITHIN_TAG}}],"inside-tag"),LEXER_WITHIN_TAG=new Lexer([{name:"punctuation",pattern:/^\s*(?:<|&lt;)(?!\/)/,after:{name:"tag",lexer:()=>LEXER_TAG_NAME}},{name:"punctuation",pattern:/(?:<|&lt;)\/(?=[A-Za-z])/,inside:{name:"element jsx-element",lexer:LEXER_JSX_CLOSING_TAG},final:!0},{name:"punctuation",pattern:/\{/,inside:{name:"interpolation",lexer:LEXER_JSX_INTERPOLATION}}],"within-tag"),LEXER_TAG_NAME=new Lexer([{name:"tag tag-html",pattern:/^[a-z\-]+(?=\s|(?:>|&gt;))/,test:(e,t,a)=>{return a.set("is-opening-tag",!0),"number"!=typeof a.get("jsx-tag-depth")&&a.set("jsx-tag-depth",0),e},after:{name:"jsx-tag-contents",lexer:LEXER_INSIDE_TAG},final:e=>e.get("only-opening-tag")},{name:"tag tag-jsx",pattern:/^[A-Z][\w\d$\.]*(?=\s|(?:>|&gt;))/,test:(e,t,a)=>{return a.set("is-opening-tag",!0),"number"!=typeof a.get("jsx-tag-depth")&&a.set("jsx-tag-depth",0),e},after:{name:"jsx-tag-contents",lexer:LEXER_INSIDE_TAG}}],"tag-name"),LEXER_TAG_OPEN_START=new Lexer([{name:"punctuation",pattern:/^\s*(?:<|&lt;)(?!\/)/,test:(e,t,a)=>(a.set("only-opening-tag",!0),e),after:{name:"tag",lexer:LEXER_TAG_NAME},final:!0}],"tag-open-start"),LEXER_TAG_ROOT=new Lexer([{name:"punctuation",pattern:/^\s*(?:<|&lt;)(?!\/)/,test:(e,t,a)=>(a.set("is-root",!0),e),after:{name:"tag",lexer:LEXER_TAG_NAME}}],"tag-root");let ESCAPES$2=new Grammar({escape:{pattern:/\\./}}),REGEX_INTERNALS$1=new Grammar({escape:{pattern:/\\./},"exclude from group begin":{pattern:/(\\\()/,replacement:"#{1}"},"group-begin":{pattern:/(\()/,replacement:'<b class="group">#{1}'},"group-end":{pattern:/(\))/,replacement:"#{1}</b>"}}),INSIDE_TEMPLATE_STRINGS$1=new Grammar({interpolation:{pattern:/(\$\{)(.*?)(\})/,captures:{1:"punctuation interpolation-start",2:()=>MAIN$3,3:"punctuation interpolation-end"},wrapReplacement:!0}}).extend(ESCAPES$2);const PARAMETERS$2=new Grammar({"parameter parameter-with-default":{pattern:/([A-Za-z$_][$_A-Za-z0-9_]*)(\s*=\s*)(.*?)(?=,|\)|\n|$)/,captures:{1:"variable parameter",2:"operator",3:()=>VALUES$2}},"keyword operator":{pattern:/\.{3}/},operator:{pattern:/=/},"variable parameter":{pattern:/[A-Za-z$_][$_A-Za-z0-9_]*/}});let STRINGS$1=new Grammar({"string string-template embedded":{pattern:/(`)((?:[^`\\]|\\\\|\\.)*)(`)/,captures:{1:"punctuation string-start",2:INSIDE_TEMPLATE_STRINGS$1,3:"punctuation string-end"},wrapReplacement:!0},"string string-single-quoted":{pattern:/(')((?:[^'\\]|\\\\|\\.)*)(')/,replacement:"<span class='#{name}'>#{1}#{2}#{3}</span>",captures:{2:ESCAPES$2}},"string string-double-quoted":{pattern:/(")((?:[^"\\]|\\\\|\\.)*)(")/,captures:{2:ESCAPES$2},wrapReplacement:!0}}),JSX_INTERPOLATION=new Grammar({"embedded jsx-interpolation":{pattern:/(\{)([\s\S]*)(\})/,index:e=>balanceByLexer$2(e,LEXER_BEFORE_JSX_INTERPOLATION),captures:{1:"punctuation embedded-start",2:()=>JSX_EXPRESSIONS,3:"punctuation embedded-end"},wrapReplacement:!0}}),JSX_ATTRIBUTES=new Grammar({string:{pattern:/('[^']*[^\\]'|"[^"]*[^\\]")/},attribute:{pattern:/\b([a-zA-Z-:]+)(=)/,replacement:compact$4("\n      <span class='attribute'>\n        <span class='#{name}'>#{1}</span>\n        <span class='punctuation'>#{2}</span>\n      </span>\n    ")}}).extend(JSX_INTERPOLATION),JSX_TAG_CONTENTS=new Grammar({});JSX_TAG_CONTENTS.extend(JSX_ATTRIBUTES),JSX_TAG_CONTENTS.extend(JSX_INTERPOLATION),JSX_TAG_CONTENTS.extend({"punctuation punctuation-tag-close":{pattern:/>|\/>/}});let JSX_TAG_ROOT=new Grammar({jsx:{pattern:/(<|&lt;)([a-zA-Z_$][a-zA-Z0-9_$\.]*\s*)([\s\S]*)(&gt;|>)/,index:e=>balanceByLexer$2(e,LEXER_TAG_ROOT),replacement:compact$4("\n      <span class='jsx'>#{0}</span>\n    "),before:e=>{e[0]=JSX_CONTENTS.parse(e[0])}}});function handleJsxOrHtmlTag(e){return e.match(/^[A-Z]/)?wrap$2(e,"tag tag-jsx"):wrap$2(e,"tag tag-html")}let JSX_TAGS=new Grammar({"meta: opening tag without attributes":{pattern:/(<|&lt;)([\w$][\w\d$\.]*)(&gt;|>)/,replacement:compact$4("\n      <span class='jsx-element element element-opening'>\n        <span class='punctuation'>#{1}</span>\n        #{2}\n        <span class='punctuation'>#{3}</span>\n      </span>\n    "),before(e,t){e[2]=handleJsxOrHtmlTag(e[2])}},"tag tag-open":{pattern:/(<|&lt;)([\w$][\w\d$\.]*)(\s+)([\s\S]*)(.)(&gt;|>)/,replacement:compact$4("\n      <span class='#{name}'>\n        <span class='punctuation'>#{1}</span>\n        #{2}#{3}#{4}#{5}\n        <span class='punctuation'>#{6}</span>\n      </span>\n    "),index:e=>balanceByLexer$2(e,LEXER_TAG_OPEN_START),before(e,t){e.name="jsx-element element element-opening",e[2]=handleJsxOrHtmlTag(e[2]),e[5]&&("/"===e[5]?(e.name=e.name.replace("element-opening","element-self"),e[5]=wrap$2(e[5],"punctuation")):(e[4]+=e[5],e[5]="")),e[4]=JSX_ATTRIBUTES.parse(e[4],t)}},"tag tag-close":{pattern:/((?:<|&lt;)\/)([\w$][\w\d_$\.]*)(\s*)(&gt;|>)/,replacement:compact$4("\n      <span class='jsx-element element element-closing'>\n        <span class='punctuation'>#{1}</span>\n        <span class='tag'>#{2}</span>#{3}\n        <span class='punctuation'>#{4}</span>\n      </span>\n    ")}}),JSX_CONTENTS=new Grammar({}).extend(JSX_INTERPOLATION,JSX_TAGS),ARROW_FUNCTION_PARAMETERS=new Grammar({params:{pattern:/(\()([^)]+)(\))/,wrapReplacement:!0,captures:{1:"punctuation",2:PARAMETERS$2,3:"punctuation"}},"variable parameter":{pattern:/[\w$][\w\d_$]*/}}),ARROW_FUNCTIONS=new Grammar({"single-parameter multiline arrow function":{pattern:/([\w$][\w\d$]*)(\s*)(=(?:>|&gt;))/,captures:{1:ARROW_FUNCTION_PARAMETERS,3:"operator"}},"meta: arrow function with params in parentheses":{pattern:/(\([^)]+\))(\s*)(=(?:>|&gt;))/,captures:{1:ARROW_FUNCTION_PARAMETERS,3:"operator"}},"single line arrow function":{pattern:/(\(?[^)]\)?|[a-zA-Z_$][a-zA-Z0-9_$]*)(\s*)(=(?:>|&gt;))(\s*)/,captures:{1:ARROW_FUNCTION_PARAMETERS,3:"operator"}}}),VALUES$2=new Grammar({});VALUES$2.extend({constant:{pattern:/\b(?:arguments|this|false|true|super|null|undefined)\b/},"number number-binary-or-octal":{pattern:/0[bo]\d+/},number:{pattern:/(?:\d*\.?\d+)/}}),VALUES$2.extend(ARROW_FUNCTIONS),VALUES$2.extend(STRINGS$1),VALUES$2.extend({comment:{pattern:/(\/\/[^\n]*\n)|(\/\*[^*]*\*+([^\/][^*]*\*+)*\/)/},regexp:{pattern:/(\/)(.*?[^\\])(\/)([mgiy]*)/,captures:{2:REGEX_INTERNALS$1,4:"keyword regexp-flags"},wrapReplacement:!0}});let DESTRUCTURING$1=new Grammar({alias:{pattern:/([A-Za-z$_][$_A-Za-z0-9_]*)(\s*)(:)(\s*)(?=\w|\{|\[)/,captures:{1:"entity"}},variable:{pattern:/[A-Za-z$_][$_A-Za-z0-9_]*/},operator:{pattern:/=/}}),IMPORT_SPECIFIERS=new Grammar({ordinary:{pattern:/(^|,)(\s*)([A-Za-z_$][A-Za-z_$0-9]*)(\s*)(?=$|,)/,captures:{1:"punctuation",3:"variable variable-import"}},"default as":{pattern:/(^|,)(\s*)(default)(\s*)(as)(\s*)([\w$][\w\d$]*)(\s*)(?=$|,)/,captures:{1:"punctuation",3:"keyword keyword-default",5:"keyword keyword-as",7:"variable variable-import"}}}),IMPORT_SPECIFIER=new Grammar({"implicit default specifier":{pattern:/^(\s*)([A-Za-z_$][A-Za-z_$0-9]*)(\s*)(?=,|$)/,captures:{2:"variable variable-import"}},specifiers:{pattern:/(\{)(\s*)([^}]+)(})/,captures:{3:IMPORT_SPECIFIERS}}}),IMPORTS=new Grammar({"import with destructuring":{pattern:/(^\s*)(import)(\s*)(?=\{)([\s\S]*?)(\s*)(from)(\s*)(.*?)(?=;|\n)/,captures:{2:"keyword keyword-import",4:IMPORT_SPECIFIER,6:"keyword keyword-from",8:STRINGS$1}},"import with source":{pattern:/(^\s*)(import)(\s*)(.*?)(\s*)(from)(\s*)(.*?)(?=;|\n)/,captures:{2:"keyword keyword-import",4:()=>IMPORT_SPECIFIER,6:"keyword keyword-from",8:()=>STRINGS$1}},"import without source":{pattern:/(^\s*)(import)(\s*)(?=\`|'|")(.*?)(?=;|\n)/,captures:{2:"keyword keyword-import",4:()=>STRINGS$1}}}),OPERATORS=new Grammar({"keyword operator":{pattern:/\|\||&&|&amp;&amp;|!==?|={1,3}|>=?|<=?|\+\+|\+|--|-|\*|[\*\+-\/]=|\?|\.{3}|\b(?:instanceof|in|of)\b/}}),JSX_EXPRESSIONS=new Grammar({});JSX_EXPRESSIONS.extend(JSX_TAGS),JSX_EXPRESSIONS.extend(VALUES$2),JSX_EXPRESSIONS.extend(ARROW_FUNCTIONS),JSX_EXPRESSIONS.extend(OPERATORS);let MAIN$3=new Grammar("javascript-jsx",{},{alias:["react","javascript"]});MAIN$3.extend(JSX_TAG_ROOT),MAIN$3.extend(IMPORTS),MAIN$3.extend(VALUES$2),MAIN$3.extend({"meta: exclude digits in the middle of identifiers":{pattern:/\$\d/,replacement:"#{0}"},"meta: properties with keyword names":{pattern:/(\.)(for|if|while|switch|catch|return)\b/,replacement:"#{0}"},"meta: functions with keyword names":{pattern:/(\s*)\b(for|if|while|switch|catch)\b/,replacement:"#{1}<span class='keyword'>#{2}</span>"},"meta: new keyword plus identifier":{pattern:/(new)(\s+)((?:[\w$][\w\d$]*\.)*)([\w$][\w\d$]*)(?=\()/,captures:{1:"keyword keyword-new",4:"entity-class"}},"meta: variable declaration":{pattern:/\b(var|let|const)(\s+)([\w$][\w\d$]*?)(\s*)(?=\s|=|;|,)/,captures:{1:"storage",3:"variable"}},"meta: variable assignment":{pattern:/(\s+|,)([A-Za-z_$][\w\d$]*?)(\s*)(?==)(?!=(?:>|&gt;))/,captures:{2:"variable"}},"meta: destructuring assignment":{pattern:/(let|var|const)(\s+)(\{|\[)([\s\S]*)(\}|\])(\s*)(=)/,index:e=>{let t=/(let|var|const|)(\s+)(\{|\[)/.exec(e)[3],a=balance$3(e,{"{":"}","[":"]"}[t],t),n=e.indexOf("=",a);e.slice(0,n+1);return n},captures:{1:"storage",4:DESTRUCTURING$1,7:"operator"}},"function function-expression":{pattern:/\b(function)(\s*)([a-zA-Z_$]\w*)?(\s*)(\()(.*?)(\))/,captures:{1:"keyword keyword-function",3:"entity",5:"punctuation",6:PARAMETERS$2,7:"punctuation"}},"function function-literal-shorthand-style":{pattern:/(^\s*)(get|set|static)?(\s*)([\w$][\w\d$]*)(\s*)(\()(.*?)(\))(\s*)(?=\{)/,captures:{2:"storage",4:"entity",6:"punctuation",7:PARAMETERS$2,8:"punctuation"}},"meta: function shorthand with computed property name":{pattern:/(])(\s*)(\()(.*?)(\))(\s*)(?=\{)/,captures:{3:"punctuation",4:PARAMETERS$2,5:"punctuation",7:"punctuation"}},"function function-assigned-to-variable":{pattern:/\b([\w$][\w\d$]*)(\s*)(=)(\s*)(function)(\s*)(\()(.*?)(\))/,captures:{1:"variable",3:"operator",5:"keyword",7:"punctuation",8:PARAMETERS$2,9:"punctuation"}},"meta: property then function":{pattern:/([A-Za-z_$][A-Za-z0-9_$]*)(:)(\s*)(?=function)/,captures:{1:"entity",2:"punctuation"}},entity:{pattern:/([A-Za-z_$][A-Za-z0-9_$]*)(?=:)/},"meta: class definition":{pattern:/(class)(?:(\s+)([A-Z][A-Za-z0-9_]*))?(?:(\s+)(extends)(\s+)([A-Z][A-Za-z0-9_$\.]*))?(\s*)({)/,index:e=>balance$3(e,"}","{",{startIndex:e.indexOf("{")+1}),replacement:compact$4('\n      <span class="storage">#{1}</span>\n      #{2}#{3}\n      #{4}#{5}#{6}#{7}\n      #{8}#{9}\n    '),captures:{1:"storage",3:"entity entity-class",5:"storage",7:"entity entity-class entity-superclass"}},storage:{pattern:/\b(?:var|let|const|class|extends|async)\b/},keyword:{pattern:/\b(?:try|catch|finally|if|else|do|while|for|break|continue|case|switch|default|return|yield|throw|await)\b/}}).extend(OPERATORS);const{balance:balance$4,wrap:wrap$3,compact:compact$5,VerboseRegExp:VerboseRegExp$5}=Utils,STRINGS$2=new Grammar({interpolation:{pattern:/\{(\d*)\}/},"escape escape-hex":{pattern:/\\x[0-9a-fA-F]{2}/},"escape escape-octal":{pattern:/\\[0-7]{3}/},escape:{pattern:/\\./}}),VALUES$3=new Grammar({lambda:{pattern:/(lambda)(\s+)(.*?)(:)/,captures:{1:"keyword storage",3:()=>PARAMETERS_WITHOUT_DEFAULT}},"string string-triple-quoted":{pattern:/"""[\s\S]*?"""/,before:(e,t)=>{e[0]=STRINGS$2.parse(e[0],t)}},"string string-raw string-single-quoted":{pattern:/([urb]+)(')(.*?[^\\]|[^\\]*)(')/,replacement:"<span class='storage string'>#{1}</span><span class='#{name}'>#{2}#{3}#{4}</span>",captures:{3:()=>STRINGS$2}},"string string-single-quoted":{pattern:/([ub])?(')((?:[^'\\]|\\.)*)(')/,replacement:"#{1}<span class='#{name}'>#{2}#{3}#{4}</span>",captures:{1:"storage string",3:()=>STRINGS$2}},"string string-double-quoted":{pattern:/([ub])?(")((?:[^"\\]|\\.)*)(")/,replacement:"#{1}<span class='#{name}'>#{2}#{3}#{4}</span>",captures:{1:"storage string",3:()=>STRINGS$2}},constant:{pattern:/\b(self|None|True|False)\b/},"constant constant-assignment":{pattern:/^([A-Z][A-Za-z\d_]*)(\s*)(?=\=)/,replacement:"<span class='#{name}'>#{1}</span>#{2}"},"constant constant-named":{pattern:/\b([A-Z_]+)(?!\.)\b/},"variable variable-assignment":{pattern:/([a-z_][[A-Za-z\d_]*)(\s*)(?=\=)/,replacement:"<span class='#{name}'>#{1}</span>#{2}"},number:{pattern:/(\b|-)((0(x|X)[0-9a-fA-F]+)|([0-9]+(\.[0-9]+)?))\b/},"number number-binary":{pattern:/0b[01]+/},"number number-octal":{pattern:/0o[0-7]+/}}),ARGUMENTS=new Grammar({"meta: parameter with default":{pattern:/(\s*)([A-Za-z0-9_]+)(\s*=\s*)(.*?)(?=,|$)/,captures:{2:"variable parameter",3:"keyword punctuation",4:VALUES$3}}}).extend(VALUES$3),PARAMETERS_WITHOUT_DEFAULT=new Grammar({"meta: parameter":{pattern:/(\s*)(\*\*?)?([A-Za-z0-9_]+)(?=,|$)/,captures:{2:"keyword operator",3:"variable parameter"}}}),PARAMETERS$3=new Grammar({"meta: parameter with default":{pattern:/(\s*)([A-Za-z0-9_]+)(\s*=\s*)(.*?)(?=,|$)/,captures:{2:"variable parameter",3:"keyword punctuation",4:()=>VALUES$3}}}).extend(PARAMETERS_WITHOUT_DEFAULT),MAIN$4=new Grammar("python",{"storage storage-type support":{pattern:/(int|float|bool|chr|str|bytes|list|dict|set)(?=\()/},"support support-builtin":{pattern:/(repr|round|print|input|len|min|max|sum|sorted|enumerate|zip|all|any|open)(?=\()/},"meta: from/import/as":{pattern:/(from)(\s+)(.*?)(\s+)(import)(\s+)(.*?)(\s+)(as)(\s+)(.*?)(?=\n|$)/,captures:{1:"keyword",5:"keyword",9:"keyword"}},"meta: from/import":{pattern:/(from)(\s+)(.*?)(\s+)(import)(\s+)(.*?)(?=\n|$)/,captures:{1:"keyword",5:"keyword"}},"meta: subclass":{pattern:/(class)(\s+)([\w\d_]+)(\()([\w\d_]*)(\))(\s*)(:)/,captures:{1:"keyword",3:"entity entity-class",4:"punctuation",5:"entity entity-class entity-superclass",6:"punctuation",8:"punctuation"}},"meta: class":{pattern:/(class)(\s+)([\w\d_]+)(:)/,captures:{1:"keyword",3:"entity entity-class",4:"punctuation"}},comment:{pattern:/#[^\n]*(?=\n)/},keyword:{pattern:/\b(?:if|else|elif|print|class|pass|from|import|raise|while|try|finally|except|return|global|nonlocal|for|in|del|with)\b/},"meta: method definition":{pattern:/(def)(\s+)([A-Za-z0-9_!?]+)(\s*)(\()(.*?)?(\))/,captures:{1:"keyword",3:"entity",5:"punctuation",6:PARAMETERS$3,7:"punctuation"}},"meta: method invocation":{pattern:/([A-Za-z0-9_!?]+)(\s*)(\()(\s*)([\s\S]*)(\s*\))/,index:e=>balance$4(e,")","(",e.indexOf("(")),captures:{3:"punctuation",5:()=>ARGUMENTS,6:"punctuation"}},"keyword operator operator-logical":{pattern:/\b(and|or|not)\b/},"keyword operator operator-bitwise":{pattern:/(?:&|\||~|\^|>>|<<)/},"keyword operator operator-assignment":{pattern:/=/},"keyword operator operator-comparison":{pattern:/(?:>=|<=|!=|==|>|<)/},"keyword operator operator-arithmetic":{pattern:/(?:\+=|\-=|=|\+|\-|%|\/\/|\/|\*\*|\*)/}});MAIN$4.extend(VALUES$3);const{balance:balance$5,compact:compact$6,VerboseRegExp:VerboseRegExp$6}=Utils;function includes(e,t){return e.indexOf(t)>-1}function hasOnlyLeftBrace(e){return includes(e,"{")&&!includes(e,"}")}function findEndOfHash(e,t){let a=e.slice(t).join(""),n=balance$5(a,"}","{",{stackDepth:1});if(-1===n)return;let r=0;for(let a=t;a<e.length;a++)if((r+=e[a].length)>=n)return a}function rejoinHash(e,t,a){let n=[];for(let r=t;r<=a;r++)n.push(e[r]);return n.join(",")}function parseParameters(e,t,a){t||(t=PARAMETERS$4);let n=e.split(/,/),r=[];for(let e,t=0;t<n.length;t++)if(hasOnlyLeftBrace(e=n[t])){let e=findEndOfHash(n,t+1),a=rejoinHash(n,t,e);r.push(a),t=e}else r.push(e);return r.map(e=>t.parse(e,a))}const PARAMETERS$4=new Grammar({"meta: parameter with default":{pattern:/^(\s*)([A-Za-z0-9_]+)(\s*=\s*)(.*)/,captures:{2:"variable parameter",3:"keyword operator",4:()=>VALUES$4}},"meta: variable":{pattern:/^(\s*)([A-Za-z0-9_]+)$/,captures:{2:"variable parameter"}}}),BLOCK_PARAMETERS=new Grammar({"meta: block variable":{pattern:/^(\s*)([A-Za-z0-9_]+)$/,replacement:"#{1}<span class='#{name}'>#{2}</span>",captures:{2:"variable parameter"}}}),VALUES$4=new Grammar({"string string-single-quoted":{pattern:/(')([^']*?)(')/},"string string-double-quoted":{pattern:/(")(.*?[^\\])(")/,wrapReplacement:!0,captures:{2:()=>STRINGS$3}},"string string-double-quoted empty":{pattern:/\"\"/},"string string-percent-q string-percent-q-braces":{pattern:/(%Q\{)([\s\S]*)(\})/,index:e=>balance$5(e,"}","{",{startIndex:e.indexOf("{")}),wrapReplacement:!0,captures:{2:()=>STRINGS$3}},"string string-percent-q string-percent-q-brackets":{pattern:/(%Q\[)(.*?[^\\])(\])/,wrapReplacement:!0,captures:{2:()=>STRINGS$3}},"string embedded string-shell-command":{pattern:/(`)([^`]*?)(`)/,wrapReplacement:!0,captures:{2:()=>STRINGS$3}},constant:{pattern:/\b(self|true|false|nil(?!\?))\b/},"number binary":{pattern:/\b0b[01](?:_[01]|[01])*\b/},number:{pattern:/\b(\d(?:[_.]\d|\d)*)\b/},"punctuation punctuation-namespace":{pattern:/(::)/},symbol:{pattern:/:[A-Za-z0-9_!?]+/},"symbol single-quoted":{pattern:/:'([^']*?)'/},"symbol double-quoted":{pattern:/(:)(")(.*?[^\\])(")/,wrapReplacement:!0,captures:{3:()=>STRINGS$3}},regexp:{pattern:/(\/)(.*?)(\/)/,wrapReplacement:!0,captures:{2:()=>REGEX_INTERNALS$2}},"variable variable-instance":{pattern:/(@)[a-zA-Z_][\w\d]*/},"variable variable-global":{pattern:/(\$)[a-zA-Z_][\w\d]*/},keyword:{pattern:/\b(do|class|def|if|module|yield|then|else|for|until|unless|while|elsif|case|when|break|retry|redo|rescue|require|lambda)\b/}}),REGEX_INTERNALS$2=new Grammar({escape:{pattern:/\\./},"meta: exclude from group begin":{pattern:/\\\(/,replacement:"#{0}"},"group-begin":{pattern:/(\()/,replacement:'<b class="group">#{1}'},"group-end":{pattern:/(\))/,replacement:"#{1}</b>"}}),STRINGS$3=new Grammar({escape:{pattern:/\\./},interpolation:{pattern:/(#\{)(.*?)(\})/,captures:{1:"punctuation",2:()=>MAIN$5,3:"punctuation"},wrapReplacement:!0}}),MAIN$5=new Grammar("ruby",{"meta: method definition":{pattern:/(def)(\s+)([A-Za-z0-9_!?.]+)(?:\s*(\()(.*?)(\)))?/,captures:{1:"keyword",3:"entity"},before:(e,t)=>{e[5]&&(e[5]=parseParameters(e[5],null,t))}},"block block-braces":{pattern:/(\{)(\s*)(\|)([^|]*?)(\|)/,replacement:compact$6("\n      <b class='#{name}'>\n        <span class='punctuation brace'>#{1}</span>#{2}\n        <span class='punctuation pipe'>#{3}</span>\n        #{4}\n        <span class='punctuation pipe'>#{5}</span>\n    "),before:(e,t)=>{t.get("bracesStack",[]).push(e.name),e[4]=parseParameters(e[4],BLOCK_PARAMETERS,t)}},"block block-do-end":{pattern:/(do)(\s*)(\|)([^|]*?)(\|)/,replacement:compact$6("\n      <b class='#{name}'>\n        <span class='keyword'>#{1}</span>#{2}\n        <span class='punctuation pipe'>#{3}</span>\n        #{4}\n        <span class='punctuation pipe'>#{5}</span>\n    "),before:(e,t)=>{t.get("bracesStack",[]).push(e.name),e[4]=parseParameters(e[4],null,t),e[6]=MAIN$5.parse(e[6],t)}},"meta: class definition with superclass":{pattern:/(class)(\s+)([A-Z][A-Za-z0-9_]*)(\s*(?:<|&lt;)\s*)([A-Z][A-Za-z0-9:_]*)/,replacement:compact$6("\n      <span class='keyword'>#{1}</span>#{2}\n      <span class='class-definition-signature'>\n        <span class='class'>#{3}</span>#{4}<span class='class superclass'>#{5}</span>\n      </span>\n    ")},"meta: class or module definition":{pattern:/(class|module)(\s+)([A-Z][A-Za-z0-9_]*)\s*(?=$|\n)/,replacement:compact$6("\n      <span class='keyword'>#{1}</span>#{2}\n      <span class='class-definition-signature'>\n        <span class='class'>#{3}</span>\n      </span>\n    ")},"string heredoc-indented":{pattern:/(&lt;&lt;-|<<-)([_\w]+?)\b([\s\S]+?)(\2)/,replacement:compact$6("\n      <span class='#{name}'>\n        <span class='heredoc-begin'>#{1}#{2}</span>\n        #{3}\n        <span class='heredoc-end'>#{4}</span>\n      </span>\n    "),captures:{2:()=>STRINGS$3}},"keyword operator":{pattern:/(\+|-|\*|\/|>|&gt;|<|&lt;|=>|=&gt;|>>|&gt;&gt;|<<|&lt;&lt;|=~|\|\|=|==|=|\|\||&&|\+=|-=|\*=|\/=)/},"keyword special":{pattern:/\b(initialize|new|loop|extend|raise|attr|catch|throw|private|protected|public|module_function|attr_(?:reader|writer|accessor))\b/}});MAIN$5.extend(VALUES$4),MAIN$5.extend({comment:{pattern:/#[^\n]+/},"bracket-block-end":{pattern:/\}/,replacement:"#{0}",after:(e,t)=>{let a=t.get("bracesStack",[]).pop();if(a)return"".concat(e,"\x3c!-- close ").concat(a," --\x3e</b>")}},"keyword keyword-block-end":{pattern:/\b(end)\b/,after:(e,t)=>{let a=t.get("bracesStack",[]).pop();if(a)return"".concat(e,"\x3c!-- close ").concat(a," --\x3e</b>")}}});const{balance:balance$6,compact:compact$7,VerboseRegExp:VerboseRegExp$7}=Utils;let findFirstThatIsNotPrecededBy=(e,t,a,n)=>{let r;for(let s=n;s<a.length;s++){let n=a.slice(s,s+e.length);if(r!==t&&n===e)return s;r=n.slice(-1)}};const FUNCTIONS=new Grammar({"support support-function-call support-function-call-css-builtin":{pattern:/(attr|counter|rgb|rgba|hsl|hsla|calc)(\()(.*)(\))/,replacement:"<span class='#{name}'>#{1}</span>#{2}#{3}#{4}",captures:{2:"punctuation",3:()=>VALUES$5,4:"punctuation"}},"support support-function-call support-function-call-sass":{pattern:/(red|green|blue|mix|hue|saturation|lightness|adjust-hue|lighten|darken|saturate|desaturate|grayscale|complement|invert|alpha|opacity|opacify|transparentize|fade-in|fade-out|selector-(?:nest|replace)|unquote|quote|str-(?:length|insert|index|slice)|to-(?:upper|lower)-case|percentage|round|ceil|floor|abs|min|max|random|(?:feature|variable|global-variable|mixin)-exists|inspect|type-of|unit|unitless|comparable|call|if|unique-id)(\()(.*)(\))/,replacement:"<span class='#{name}'>#{1}</span>#{2}#{3}#{4}",captures:{2:"punctuation",3:()=>VALUES$5,4:"punctuation"}},"support support-function-call support-function-call-url":{pattern:/(url)(\()(.*)(\))/,index:e=>balance$6(e,")","(",{startIndex:e.indexOf("(")}),replacement:"<span class='#{name}'>#{1}</span>#{2}#{3}#{4}",before:(e,t)=>{let a=INSIDE_URL_FUNCTION.parse(e[3],t);/^('|")/.test(e[3])||(a=INTERPOLATIONS.parse(e[3],t),a="<span class='string string-unquoted'>".concat(a,"</span>")),e[3]=a}},"support support-function-call support-function-call-custom":{pattern:/([A-Za-z_-][A-Za-z0-9_-]*)(\()(.*)(\))/,replacement:"<span class='#{name}'>#{1}</span>#{2}#{3}#{4}",captures:{2:"punctuation",3:()=>VALUES$5,4:"punctuation"}}}),INTERPOLATIONS=new Grammar({interpolation:{pattern:/(\#\{)(.*?)(})/,captures:{1:"punctuation interpolation-begin",2:()=>VALUES$5,3:"punctuation interpolation-end"},wrapReplacement:!0}});function variableRuleNamed(e){return new Grammar({[e]:{pattern:/\$[A-Za-z0-9_-]+/}})}const VARIABLE=variableRuleNamed("variable"),VARIABLES=new Grammar({"variable variable-assignment":{pattern:/(\s*)(\$[A-Za-z][A-Za-z0-9_-]*)\b(\s*)(\:)([\s\S]*?)(;)/,captures:{2:"variable variable-assignment",4:"punctuation",5:()=>VALUES$5}}}).extend(VARIABLE),PARAMETERS$5=new Grammar({"parameter parameter-with-default":{pattern:/(\$[A-Za-z][A-Za-z0-9_-]*)(\s*:\s*)(.*?)(?=,|\)|\n)/,replacement:compact$7('\n      <span class="parameter">\n        #{1}#{2}#{3}\n      </span>\n    '),captures:{1:"variable",2:"punctuation",3:()=>VALUES$5}}}).extend(variableRuleNamed("variable parameter")),SELECTORS=new Grammar({"selector selector-class selector-abstract-class":{pattern:/(%)[a-zA-Z0-9_-]+/},"selector selector-element-wildcard":{pattern:/\*/},"selector selector-element":{pattern:/\b(a|abbr|acronym|address|area|article|aside|applet|audio|b|base|bdo|big|blockquote|body|br|button|canvas|caption|center|cite|code|col|colgroup|command|datalist|dd|del|details|dfn|div|dl|dt|em|embed|fieldset|figcaption|figure|footer|form|(h[1-6])|head|header|hgroup|hr|html|i|iframe|img|input|ins|keygen|kbd|label|legend|li|link|main|map|mark|menu|meta|meter|nav|noscript|object|ol|optgroup|option|output|p|param|picture|pre|progress|q|rp|rt|ruby|s|samp|script|section|select|small|source|span|strike|strong|style|sub|summary|sup|svg|table|tbody|td|textarea|tfoot|th|thead|time|title|tr|tt|u|ul|var|video)\b/},"selector selector-class":{pattern:/\.[a-zA-Z][a-zA-Z0-9_\-]*\b/},"selector selector-id":{pattern:/#[a-zA-Z][a-zA-Z0-9_-]*/},"selector selector-pseudo selector-pseudo-not":{pattern:/(:not\()(.*)(\))/,replacement:compact$7("\n      <span class='#{name}'>\n        #{1}\n        <span class='parameter'>#{2}</span>\n        #{3}\n      </span>\n    "),captures:{2:()=>SELECTORS}},"selector selector-self-reference-bem-style":{pattern:/(?:&amp;|&)(?:__|--)(?:[A-Za-z0-9_-]+)?/},"selector selector-interpolation":{pattern:/(#\{)(.*)(\})/,index:e=>balance$6(e,"}","{",{startIndex:e.indexOf("{")}),wrapReplacement:!0,captures:{2:()=>VALUES$5}},"selector selector-self-reference":{pattern:/(?:&amp;|&)/},"selector selector-pseudo selector-pseudo-with-args":{pattern:/((?:\:+)\b(?:lang|nth-(?:last-)?child|nth-(?:last-)?of-type))(\()(.*)(\))/,wrapReplacement:!0,captures:{3:()=>VALUES$5}},"selector selector-pseudo selector-pseudo-without-args":{pattern:/(:{1,2})(link|visited|hover|active|focus|targetdisabled|enabled|checked|indeterminate|root|first-child|last-child|first-of-type|last-of-type|only-child|only-of-type|empty|valid|invalid)/},"selector selector-pseudo selector-pseudo-element":{pattern:/(:{1,2})(-(?:webkit|moz|ms)-)?\b(after|before|first-letter|first-line|selection|any-link|local-link|(?:input-)?placeholder|focus-inner|matches|nth-match|column|nth-column)\b/},"selector selector-attribute":{pattern:/(\[)([A-Za-z_-][A-Za-z0-9_-]*)(?:([~\.$^]?=)((['"])(?:.*?)(?:\5)|[^\s\]]))?(\])/,wrapReplacement:!0,captures:{4:()=>STRINGS$4}},"selector selector-combinator":{pattern:/(\s*)([>+~])(\s*)/,replacement:"#{1}<span class='#{name}'>#{2}</span>#{3}"}}),MAPS=new Grammar({"meta: map pair":{pattern:/([a-zA-Z_-][a-zA-Z0-9_-]*)(\s*:\s*)(.*(?:,|\)|$))/,captures:{1:"entity",2:"punctuation",3:()=>VALUES$5}}}),OPERATOR_LOGICAL=new Grammar({"operator operator-logical":{pattern:/\b(and|or|not)\b/}}),OPERATORS$1=new Grammar({"operator operator-arithmetic":{pattern:/\*|\+|\-(?=\s|\(|\d|$)|\//},"operator operator-comparison":{pattern:/!=|==|</}}).extend(OPERATOR_LOGICAL),VALUES$5=new Grammar({"meta: possible map":{pattern:/(\()([\s\S]+)(\))/,replacement:"#{1}#{2}#{3}",before:(e,t)=>{let a=VALUES$5;/[A-Za-z_-][A-Za-z0-9_-]*:.*(?:,|\)|$)/.test(e[2])&&(a=MAPS),e[2]=a.parse(e[2],t)}},"constant constant-boolean":{pattern:/\b(?:true|false)\b/},constant:{pattern:/\b(?:null)\b/},"support support-property-value":{pattern:/inherit|initial|unset|none|auto|inline-block|block|inline|absolute|relative|solid|dotted|dashed|nowrap|normal|bold|italic|underline|overline|double|uppercase|lowercase|(?:border|content)-box/},"meta: value with unit":{pattern:/([\+|\-]?(?:\s*)?(?:[0-9]+(?:\.[0-9]+)?|\.[0-9]+))(\s*)((?:ch|cm|deg|dpi|dpcm|dppx|em|ex|grad|in|mm|ms|pc|pt|px|rad|rem|turn|s|vh|vmin|vw)\b|%)/,captures:{1:"number",3:"unit"}}}).extend(OPERATORS$1,VARIABLE),NUMBERS=new Grammar({number:{pattern:/[\+|\-]?(\s*)?([0-9]+(\.[0-9]+)?|\.[0-9]+)/}}),STRINGS$4=new Grammar({"string single-quoted":{pattern:/(')([^']*?)(')/,wrapReplacement:!0,captures:{2:INTERPOLATIONS}},"string double-quoted":{pattern:/(")(.*?[^\\])(")/,wrapReplacement:!0,captures:{2:INTERPOLATIONS}},"string single-quoted string-empty":{pattern:/''/},"string double-quoted string-empty":{pattern:/""/}}),COLORS=new Grammar({"constant color-hex":{pattern:/#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})\b/},"constant color-named":{pattern:/\b(aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow)\b/}}),DIRECTIVES=new Grammar({"keyword directive":{pattern:/\s+!(?:default|important|optional)/}});VALUES$5.extend(FUNCTIONS,STRINGS$4,COLORS,NUMBERS,DIRECTIVES,{support:{pattern:/\b([\w-]+)\b/}});const COMMENTS$1=new Grammar({"comment comment-line":{pattern:/(?:\s*)\/\/(?:.*?)(?=\n)/},"comment comment-block":{pattern:/(?:\s*)(\/\*)([\s\S]*)(\*\/)/}}),PROPERTIES=new Grammar({"meta: property pair":{pattern:/([\-a-z]+)(\s*:\s*)([^;]+)(;)/,captures:{1:"property",3:()=>VALUES$5}}}),INSIDE_AT_RULE_MEDIA=new Grammar({support:{pattern:/\b(?:only|screen)\b/},"meta: property group":{pattern:/(\()(.*)(\))/,replacement:"#{1}#{2}#{3}",captures:{2:()=>MEDIA_AT_RULE_PROP_PAIR}}}).extend(OPERATOR_LOGICAL),INSIDE_AT_RULE_IF=new Grammar({}).extend(FUNCTIONS,OPERATORS$1,VALUES$5),INSIDE_AT_RULE_INCLUDE=new Grammar({}).extend(PARAMETERS$5,VALUES$5,{"string string-unquoted":{pattern:/\b\w+\b/}}),INSIDE_AT_RULE_KEYFRAMES=new Grammar({"meta: from/to":{pattern:/\b(from|to)\b(\s*)(?={)/,captures:{1:"keyword"}},"meta: percentage":{pattern:/(\d+%)(\s*)(?={)/,captures:{1:()=>VALUES$5}}}).extend(PROPERTIES),INSIDE_AT_RULE_SUPPORTS=new Grammar({"meta: property pair":{pattern:/([\-a-z]+)(\s*:\s*)([^;]+)(?=\)|$)/,replacement:'<span class="property">#{1}</span>#{2}#{3}#{4}',captures:{1:"property",2:"punctuation",3:()=>VALUES$5}}}).extend(OPERATOR_LOGICAL),MEDIA_AT_RULE_PROP_PAIR=new Grammar({"meta: property pair":{pattern:/([\-a-z]+)(\s*:\s*)([^;]+)(?=\)|$)/,captures:{1:"property",3:()=>VALUES$5}}}),INSIDE_URL_FUNCTION=new Grammar({}).extend(STRINGS$4,VARIABLES,FUNCTIONS),AT_RULES=new Grammar({"meta: at-rule":{pattern:/(@(?:elseif|if|else))(.*)({)/,captures:{1:"keyword keyword-at-rule keyword-at-rule-if",2:INSIDE_AT_RULE_IF}},"keyword keyword-at-rule keyword-at-rule-keyframes":{pattern:/(@keyframes)(\s+)([a-z-]+)(\s*)({)([\s\S]*)(})/,index:e=>balance$6(e,"}","{",{startIndex:e.indexOf("{")}),captures:{1:"keyword keyword-at-rule keyword-at-rule-keyframes",3:"entity",6:INSIDE_AT_RULE_KEYFRAMES}},"keyword keyword-at-rule keyword-at-rule-log-directive":{pattern:/(@(?:error|warn|debug))(\s+|\()(.*)(\)?;)(\s*)(?=\n)/,replacement:"<span class='#{name}'>#{1}</span>#{2}#{3}#{4}#{5}",captures:{3:STRINGS$4}},"keyword keyword-at-rule keyword-at-rule-each":{pattern:/(@each)(.*)\b(in)\b(.*)(\{)/,replacement:"<span class='#{name}'>#{1}</span>#{2}#{3}#{4}#{5}",captures:{2:()=>VARIABLES,3:"keyword",4:()=>VALUES$5}},"keyword keyword-at-rule keyword-at-rule-for":{pattern:/(@for)(.*)\b(from)\b(.*)(through)(.*)({)/,replacement:compact$7("\n      <span class='#{name}'>#{1}</span>\n      #{2}#{3}#{4}#{5}#{6}#{7}\n    "),captures:{2:()=>VARIABLES,3:"keyword",4:()=>VALUES$5,5:"keyword",6:()=>VALUES$5}},"keyword keyword-at-rule keyword-at-rule-mixin":{pattern:/(@mixin)(\s+)([A-Za-z-][A-Za-z0-9\-_]+)(?:(\s*\())?(.*)(?={)/,replacement:compact$7("\n      <span class='#{name}'>#{1}</span>#{2}#{3}#{4}#{5}\n    "),captures:{3:"function",5:PARAMETERS$5}},"keyword keyword-at-rule keyword-at-rule-function":{pattern:/(@function)(\s+)([A-Za-z-][A-Za-z0-9\-_]+)(?:(\s*\())?(.*)(?={)/,replacement:compact$7("\n      <span class='#{name}'>#{1}</span>\n      #{2}#{3}#{4}#{5}\n    "),captures:{3:"function",5:PARAMETERS$5}},"keyword keyword-at-rule keyword-at-rule-extend":{pattern:/(@extend)(\s+)(.*)(;)/,replacement:"<span class='#{name}'>#{1}</span>#{2}#{3}#{4}",before:(e,t)=>{e[3]=SELECTORS.parse(e[3],t),e[3]=e[3].replace(/(class=)(["'])(?:selector)\b/g,"$1$2entity parameter"),/!optional$/.test(e[3])&&(e[3]=e[3].replace(/(!optional)$/,"<span class='keyword keyword-directive'>$1</span>"))}},"keyword keyword-at-rule keyword-at-rule-include":{pattern:/(@include)(\s+)([A-Za-z][A-Za-z0-9\-_]+)(?:(\s*\())?([\s\S]*?)(;|\{)/,replacement:"<span class='#{name}'>#{1}</span>#{2}#{3}#{4}#{5}#{6}",captures:{3:"function",5:INSIDE_AT_RULE_INCLUDE}},"keyword keyword-at-rule keyword-at-rule-media":{pattern:/(@media)(.*)({)/,replacement:"<span class='#{name}'>#{1}</span>#{2}#{3}",captures:{2:INSIDE_AT_RULE_MEDIA}},"keyword keyword-at-rule keyword-at-rule-import":{pattern:/(@import)(.*)(;)/,replacement:"<span class='#{name}'>#{1}</span>#{2}#{3}",captures:{2:STRINGS$4}},"keyword keyword-at-rule keyword-at-rule-content":{pattern:/(@content)(?=;)/},"keyword keyword-at-rule keyword-at-rule-charset":{pattern:/(@charset)(\s+)(.*)(;)(\s*)(?=\n|$)/,replacement:"<span class='#{name}'>#{1}</span>#{2}#{3}#{4}#{5}",captures:{3:STRINGS$4}},"keyword keyword-at-rule keyword-at-rule-namespace":{pattern:/(@namespace)(\s+)(?:([a-zA-Z][a-zA-Z0-9]+)(\s+))?([^\s]*)(;)(?=\n|$)/,replacement:"<span class='#{name}'>#{1}</span>#{2}#{3}#{4}#{5}#{6}",captures:{3:"selector",5:FUNCTIONS},before:(e,t)=>{e[3]||(e[4]="")}},"keyword keyword-at-rule keyword-at-rule-supports":{pattern:/(@supports)(\s+)(.*)({)(\s*)(?=\n)/,replacement:"<span class='#{name}'>#{1}</span>#{2}#{3}#{4}#{5}",captures:{3:INSIDE_AT_RULE_SUPPORTS}},"keyword keyword-at-rule keyword-at-rule-font-face":{pattern:/(@font-face)(\s*)({)(\s*)(?=\n)/,replacement:"<span class='#{name}'>#{1}</span>#{2}#{3}#{4}"},"keyword keyword-at-rule keyword-at-rule-return":{pattern:/(@return)(\s+)(.*)(;)/,replacement:"<span class='#{name}'>#{1}</span>#{2}#{3}#{4}",captures:{3:()=>VALUES$5}}}),MAIN$6=new Grammar("scss",{});MAIN$6.extend(FUNCTIONS,VARIABLES,AT_RULES),MAIN$6.extend({"meta: selector line":{pattern:/(^\s*)((?:[>\+~]|\.|\#|\[|(?:&|&amp;)|%|\*|(?:a|abbr|acronym|address|area|article|aside|audio|b|base|big|blockquote|body|br|button|canvas|caption|cite|code|col|colgroup|datalist|dd|del|details|dfn|dialog|div|dl|dt|em|eventsource|fieldset|figure|figcaption|footer|form|frame|frameset|(?:h[1-6])|head|header|hgroup|hr|html|i|iframe|img|input|ins|kbd|label|legend|li|link|main|map|mark|menu|meta|meter|nav|noframes|noscript|object|ol|optgroup|option|output|p|param|pre|progress|q|samp|script|section|select|small|span|strike|strong|style|sub|summary|sup|svg|table|tbody|td|textarea|tfoot|th|thead|time|title|tr|tt|ul|var|video)\b).*)(,|\{)/,index:e=>{return findFirstThatIsNotPrecededBy("{","#",e,0)},captures:{2:SELECTORS}}}),MAIN$6.extend(PROPERTIES,COMMENTS$1);const INSIDE_STRINGS=new Grammar({variable:{pattern:/(\$[\d\w_\-]+)\b|(\$\{[\d\w_\-]+\})/}}),INSIDE_SHELL_COMMANDS=new Grammar({variable:{pattern:/(\$[\w_\-]+)\b/}}),MAIN$7=new Grammar("shell",{comment:{pattern:/#[^\n]*(?=\n|$)/},string:{pattern:/(?:'[^']*'|"[^"]*")/,before:(e,t)=>{e[0]=INSIDE_STRINGS.parse(e[0],t)}},function:{pattern:/(\w[\w\d_\-]+)(?=\()/},"shell-command shell-command-backticks":{pattern:/`[^`]*`/,before:(e,t)=>{e[0]=INSIDE_SHELL_COMMANDS.parse(e[0],t)}},"shell-command":{pattern:/\$\(.*?\)/,before:(e,t)=>{e[0]=INSIDE_SHELL_COMMANDS.parse(e[0],t)}},"support support-builtin":{pattern:/\b(?:sudo|chmod|cd|mkdir|ls|cat|echo|touch|mv|cp|rm|ln|sed|awk|tr|xargs|yes|pbcopy|pbpaste)\b/},"support support-other":{pattern:/\b(?:ruby|gem|rake|python|pip|easy_install|node|npm|php|perl|bash|sh|zsh|gcc|go|mate|subl|atom)\b/},number:{pattern:/\b(?:[0-9]+(\.[0-9]+)?)\b/},constant:{pattern:/\b(?:false|true)\b/},"constant constant-home":{pattern:/(^|\s*|\n)~(?=\b|\/)/},keyword:{pattern:/\b(?:if|fi|case|esac|for|do|else|then|while|exit|done|shift)\b/},operator:{pattern:/>|&gt;|&&|&amp;&amp;/},variable:{pattern:/(\$[\w_\-]+)\b/},"variable-assignment":{pattern:/([A-Za-z_][A-Za-z0-9_]*)(=)/,replacement:"<span class='variable'>#{1}</span><span class='operator'>#{2}</span>"},"variable variable-in-braces":{pattern:/\$\{.+?}(?=\n|\b)/}},{alias:["bash"]});function findFirstTextNode(e){let{childNodes:t}=e;if(0===t.length)return null;for(let e=0;e<t.length;e++){let a=t[e];if(a.nodeType===Node.TEXT_NODE)return a;let n=findFirstTextNode(a);if(n)return n}return null}function findLastTextNode(e){let{childNodes:t}=e;if(0===t.length)return null;for(let e=t.length-1;e>=0;e--){let a=t[e];if(a.nodeType===Node.TEXT_NODE)return a;let n=findFirstTextNode(a);if(n)return n}return null}function handler(e){let{fragment:t}=e.detail,a=findFirstTextNode(t);if(a){let e=a.nodeValue;e&&e.match(/^(\s*\n)/)&&(e=e.replace(/^(\s*\n)/,"")),a.parentNode.replaceChild(document.createTextNode(e),a)}let n=findLastTextNode(t);if(n){let e=n.nodeValue;e&&e.match(/(\s*\n)+$/)&&(e=e.replace(/(\s*\n)+$/,"")),n.parentNode.replaceChild(document.createTextNode(e),n)}}function init(){document.addEventListener("daub-will-highlight",handler)}function getLineHeight(e){let t=getComputedStyle(e);return parseFloat(t.lineHeight)}function getTopOffset(e,t){let a=document.createElement("span");a.setAttribute("class","daub-line-highlight-dummy"),a.setAttribute("aria-hidden","true"),a.textContent=" ",e.insertBefore(a,e.firstChild);let n=t.getBoundingClientRect(),r=a.getBoundingClientRect(),s=n.top-r.top;return e.removeChild(a),Math.abs(s)}function handleAttribute(e){if(!e)return null;return e.split(/,\s*/).map(function(e){let t={};if(e.indexOf("-")>-1){let[a,n]=e.split("-").map(e=>Number(e));t.start=a,t.lines=n+1-a}else t.start=Number(e),t.lines=1;return t})}function makeLine(e,t,a){let n=document.createElement("mark");n.setAttribute("class","daub-line-highlight"),n.setAttribute("aria-hidden","true"),n.textContent=new Array(e.lines).join("\n")+" ";let r=a+(e.start-1)*t-2;return Object.assign(n.style,{position:"absolute",top:r+"px",left:"0",right:"0",lineHeight:"inherit"}),n}function handler$1(e){let t=e.target,a=t.parentNode,{fragment:n}=e.detail,r=t.getAttribute("data-lines")||a.getAttribute("data-lines");if(!r)return;let s=handleAttribute(r);if(!s)return;a.style.position="relative";let p=getLineHeight(t),i=getTopOffset(t,a);s.forEach(e=>{let t=makeLine(e,p,i);n.appendChild(t)})}function init$1(){document.addEventListener("daub-will-highlight",handler$1)}const GRAMMAR_MAP={arduino:MAIN,html:MAIN$1,javascript:MAIN$2,jsx:MAIN$3,python:MAIN$4,ruby:MAIN$5,scss:MAIN$6,shell:MAIN$7},GRAMMARS={Arduino:MAIN,HTML:MAIN$1,JavaScript:MAIN$2,JSX:MAIN$3,Python:MAIN$4,Ruby:MAIN$5,SCSS:MAIN$6,Shell:MAIN$7},PLUGIN_MAP={"whitespace-normalizer":init,"line-highlighter":init$1};function init$2(){let{grammars:e=[],plugins:t=[]}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},a=new Highlighter;return e.map(e=>GRAMMAR_MAP[e]).forEach(e=>{e&&a.addGrammar(e)}),t.map(e=>PLUGIN_MAP[e]).forEach(e=>{e&&e()}),a}exports.AsyncHighlighter=AsyncHighlighter,exports.Context=Context,exports.GRAMMARS=GRAMMARS,exports.Grammar=Grammar,exports.Highlighter=Highlighter,exports.Lexer=Lexer,exports.Utils=Utils,exports.init=init$2;
